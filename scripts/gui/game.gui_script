local const     = require("scripts.lib.const")
local data      = require("scripts.lib.data")
local libcamera = require("scripts.lib.libcamera")



local props                   = {}

-- Scroll
local scroll_delta            = 130 -- How much to change the target per mouse wheel tick.
local scroll_smoothing_factor = 5   -- Use a higher factor here for a snappier feel.
local scroll_min_scroll_y     = 0   -- Set your desired bounds.
local scroll_max_scroll_y     = 450
local scroll_initial_pos      = vmath.vector3()
local scroll_current_y        = 0
local scroll_target_y         = 0
local scroll_snap_threshold   = 0.1 -- A small threshold to snap when close enough.

-- Grid
local grid_start_x            = 60  -- starting x position
local grid_start_y            = 670 -- starting y position
local grid_spacing_x          = 80  -- horizontal spacing between items
local grid_spacing_y          = 80  -- vertical spacing between items
local grid_columns            = 3   -- number of columns in the grid

-- Nodes
local prop_item_template
local scroll_child_root_node
local scroll_list_root_node


function init(self)
	msg.post(".", "acquire_input_focus")

	scroll_child_root_node = gui.get_node("scroll_child_root")
	scroll_list_root_node = gui.get_node("scroll_list_container")
	prop_item_template = gui.get_node("prop_item/container")

	gui.set_enabled(prop_item_template, false)

	scroll_initial_pos = gui.get_position(scroll_child_root_node)
	scroll_current_y   = scroll_initial_pos.y
	scroll_target_y    = scroll_initial_pos.y

	--	msg.post(const.URLS.MANAGER, const.MSG.PICK_PROP, { name = "wall_shelf_kitchen" })
end

local function setup_gui()
	local prop_position = gui.get_position(prop_item_template)
	local i = 1
	for title, prop in pairs(data.props) do
		local prop_item_clone = gui.clone_tree(prop_item_template)
		local prop_item = {}

		prop_item["container"] = prop_item_clone[hash("prop_item/container")]
		--prop_item["title"] = prop_item_clone[hash("prop_item/text")]
		prop_item["name"] = title
		--	gui.set_text(prop_item.title, title)
		--	gui.set_texture(prop_item["container"], "thumbs/" .. title)
		gui.play_flipbook(prop_item["container"], title)

		local col = (i - 1) % grid_columns
		local row = math.floor((i - 1) / grid_columns)

		local x = grid_start_x + (col * grid_spacing_x)
		local y = grid_start_y - (row * grid_spacing_y)

		prop_position.x = x
		prop_position.y = y
		gui.set_position(prop_item["container"], prop_position)
		gui.set_parent(prop_item["container"], scroll_child_root_node, true)
		gui.set_enabled(prop_item.container, true)

		table.insert(props, prop_item)
		i = i + 1
	end
end




function update(self, dt)
	if data.gui_scroll then
		local diff = scroll_target_y - scroll_current_y
		if math.abs(diff) > scroll_snap_threshold then
			scroll_current_y = scroll_current_y + diff * (1 - math.exp(-scroll_smoothing_factor * dt))
		else
			scroll_current_y = scroll_target_y -- Snap to target when close enough.
		end

		local scroll_new_pos = vmath.vector3(scroll_initial_pos.x, scroll_current_y, scroll_initial_pos.z)
		gui.set_position(scroll_child_root_node, scroll_new_pos)
	end
end

function on_message(_, message_id, message, _)
	if message_id == const.MSG.SETUP_GUI then
		setup_gui()
	end
end

function on_input(_, action_id, action)
	for _, prop in ipairs(props) do
		if action.pressed and action_id == const.TRIGGERS.MOUSE_BUTTON_1 and gui.pick_node(prop.container, action.x, action.y) then
			msg.post(const.URLS.MANAGER, const.MSG.PICK_PROP, { name = prop.name })
		end
	end

	if gui.pick_node(scroll_list_root_node, action.x, action.y) then
		data.gui_scroll = true

		if action_id == const.TRIGGERS.MOUSE_WHEEL_DOWN then
			scroll_target_y = scroll_target_y + scroll_delta
		elseif action_id == const.TRIGGERS.MOUSE_WHEEL_UP then
			scroll_target_y = scroll_target_y - scroll_delta
		end

		scroll_target_y = math.max(scroll_min_scroll_y, math.min(scroll_max_scroll_y, scroll_target_y))
	else
		data.gui_scroll = false
	end
end
